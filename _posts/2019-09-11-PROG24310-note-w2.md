---
title: PROG24310 Week 1 Note
category: Self-review
tag: PROG24310
---
# Compilation 
* Scanning (lexical analysis)
 - divides the program into **tokens**(the smallest meaningful units)
 - **tokens**:
  - identifiers
  - literals/constants
  - reserved words/keywords
  - special symbols
 - helps to save time 
 - ex. int x = 100; tokens: int, x, =, 100, ;
 - **go study regular expressions**
* Parsing (syntax analysis)
 - apply the syntax rules (gramma)
* Semantic analysis
 - relationship among different types
 - errors: type mismatch, undeclared variable, reserved identifier misuse...
* Intermediate form (IF)
 - 
* Optimization
 - takes an intermediate-code program and produces another one that does the same thing faster, or in less space
 - trying to improve the code
* Code generation phase
 - ///

# Syntax
* syntax: structure of language
* semantics: meaning of language
* finite vs infinite language **midterm question!!!**
## Language validity
* lexically valid
 - each token fits the right naming in dictionary(?)
* Syntactically valid
* Semantically valid
## Regular Expression
* []: a range of characters with a hyphen (-)
* ?: an optional item
* .: any single character
* *: one or more characters
## Lexical Structure
* Token delimiter
* Format
 - Free-format
 - Fixed format
## Context-Free Grammar and BNFs
* Context-Free Grammar (CFG)
 - the nonterminals appear singly on the left-hand sides of productions
 - each nonterminal can be replaced by ...
 - problems:
  - a legal sentence does not necessarily make sense
  - potional properties are not represented (ex. captical in the first word)
  - ...
* Backus-Naur Form (BNF)
* rules can express recursion
 - ex. (top-down approach):
          
   number => number digit
   
          => number digit digit

          => digit digit digit

          => 2 digit digit

          => 23 digit

          => 234
* **Parse tree**
## Ambiguity, Associativity, and Precedence
* ...

# Parsing Techniques
* Top-down parser
* Button-Up parser: start with input to source expression

# Data Type/Structure
## Data Type
* Predefined type
* Simple type
* Type declaration
* Anonymous type
* Type equivalence
* Type system
* Type checking
* Type inference
* Type constructors
* User-defined types
## Data Structure
* 


