---
title: PROG24310 Week 1 Note
category: Self-review
tag: PROG24310
---
# Compilation 
## Scanning (lexical analysis)
 * divides the program into **tokens**(the smallest meaningful units)
 * **tokens**:
  - identifiers
  - literals/constants
  - reserved words/keywords
  - special symbols
 - helps to save time 
 - ex. int x = 100; tokens: int, x, =, 100, ;
 - **go study regular expressions**
## Parsing (syntax analysis)
 - apply the syntax rules (gramma)
## Semantic analysis
 - relationship among different types
 - errors: type mismatch, undeclared variable, reserved identifier misuse...
* Intermediate form (IF)
 - done after semantic analysis
 - is chosen for machine independence, ease of optimizaiton or compactness
## Optimization
 - takes an intermediate-code program and produces another one that does the same thing faster, or in less space
 - trying to improve the code
## Code generation phase
 - produce assembly language or relocatable machine language

# Syntax
* syntax: structure of language
* semantics: meaning of language
### finite vs infinite language **midterm question!!!**
* finite language:
- containing a finite number of words
- string can be represeted as a regular expression (regular language)
## Language validity
* lexically valid
 - each token fits the right naming in dictionary(?)
* Syntactically valid
* Semantically valid
## Regular Expression
* []: a range of characters with a hyphen (-)
* ?: an optional item
* .: any single character
* *: one or more characters
* [pratices](https://regexone.com/lesson/introduction_abcs)
## Lexical Structure
* Token delimiter
* Format
 - Free-format
 - Fixed format
## Context-Free Grammar and BNFs
### Context-Free Grammar (CFG)
- **nonterminals: names for phrase structures, since they are broken down into further phrase structures**
- **terminals: words or token symbols that cannot be broken down further**
 - the nonterminals appear singly on the left-hand sides of productions
 - each nonterminal can be replaced by ...
 - problems:
  - a legal sentence does not necessarily make sense
  - potional properties are not represented (ex. captical in the first word)
![Example](/assets/images/post_images/prog24310-w2-1.png)
### Backus-Naur Form (BNF)
* rules can express recursion
 - ex. (top-down approach):
```        
   number => number digit
   
          => number digit digit

          => digit digit digit

          => 2 digit digit

          => 23 digit

          => 234
```

## Parse tree
* graphical depiction of the replacement process in a **derivation**
 - the process of building in a language by beginning wih the start symbol and replacing left-hand sides by choices of right-hand sides in the rules
## Ambiguity, Associativity, and Precedence
### Ambiguous (blur)
* one for which two or more distinct parse or syntax trees are possible
### Associativity
### Preceduence
# Parsing Techniques
* Top-down parser: expands nonterminals to match incoming tokens and direcctly construct a derivation
* Button-Up parser: start with input to source expression

# Data Type/Structure
## Data Type
* Predefined type
* Simple type
* Type declaration
* Anonymous type: a type with no name, can use **typeof** in C to assign a name
* Type equivalence: rule for determining if two types are the same
* **Type system**: methods for constructing types, the type equivalence algorithm, type inference rules, and type corectness rules
* Type checking
* Type inference: the process of attaching types to **expressions**
* Type constructors: mechanisms used with a group of basic types to construct more complex types
* User-defined types
* **in C, long is equivelent to long int**
## Data Structure
* is a specific organization of data and family of algorighms for implementing and ADT
### ADT
* a data type together with the operations
- ex. List with operations *insert* and *delete*, Stack with operations *push* and *pop*
### Trade-offs
* time vs. space
* one operation more efficient if another less efficient
* generality vs. simplicity vs. performance

