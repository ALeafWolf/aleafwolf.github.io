---
title: PROG24310 Week 3 Note
category: Self-review
tag: PROG24310
---

# Imperative Programming
## Turing Complete
* variables
* assignments
* conditions 
## Procedural abstraction
* allows the programmer to be concerned mainly with a function interface, ignoring the details of how it is computed

# Expressions and Statements
## Side Effect
* order of operation matter, cause side effect
* permenent change of state
## Expression
* a combination of one or more constants, variables, operators, and functions that the programming language interprets
* it yields a value
* ex. 2 + 3 * 4
* basic expressions consist of **literals** and **identifiers**
* complex expression
* levels of operators differ languages
* **return a value and produces no side effect**
## Statement
* a syntactic unit of an imperative programming language that expresses some **action** to be carried out
* ex. x = 2 + 3 * 4
* **returns no value and executed for its side effects**
* if-statement
 - dangling-else problem
* case-statement / switch-statement
* iteration statement
 - for loops
 - while, do-while loops
## Assignment statement
* target = expression
* **Copy semantics**: expression is evaluated to a **value**, which is copied to the target; used by imperative languages (value-oriented languages)
* **Reference semantics**: expression is evaluated to an **object**, which pointer is copied to the target; (reference-oriented languages)
## Side Effects
* some permanent state change caused by execution of a function or statement
 - in program memory, non-local variables, input and output
* **are fundaments to the whole Von Neumann Model of Computing**
* In pure functional, logic and dataflow languages, there should be **no side effects**
## Expression vs Statement-oriented languages
* Expression-oriented
 - functional languages (List, Scheme, ML)
* Statement-oriented
 - most imperative languages
* C halfway in-between
## Short-circuit Evaluation
* avoid it
## The GOTO Controversy
* unnecessary and harmful in C 
## Loop Exits
* structured and unstructured exit
* avoid **unstructured loop**
## Recursion
* break the task into smaller subtasks
### Head recursion
* the recursive call occurs at the beginning of a method, it saves the state before jumping into the next recursive call
### Tail recursion
* no computation follows recursive call
* faster than head: no need to contain the changed state

# Functions and Procedures
* blocks whoes execution is deferred and whose interfaces are clearly specified
* Functions produce a value only and have no side effect
* Procedures produce no value only and operate by producing side effects