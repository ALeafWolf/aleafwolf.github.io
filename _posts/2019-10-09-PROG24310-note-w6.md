---
title: PROG24310 Week 6 Note
category: Self-review
tag: PROG24310
---
# String and pointer
## const
* **pointer to a constant**: const int *ptr or int const *ptr
* **constant pointer to variable**: int *const ptr
 - cannot change the pointer to point to another variable
* **Constant pointer to constant**: const int *const ptr
 - cannot change value is pointered and the pointer itself
## copy string
* use strlen(input) + 1 for strncpy() instead of sizeof(input)
### strncpy() vs. memcpy()
* strncpy|() will change the __garbage (anything after first \0)__ from source to \0, memcpy() will reamain the same
* use sizeof() as the length will not include the \0 in string
### stack buffer overflow/stack buffer overrun
* it occurs when a program writes to a memory address on the program's call stack outside of the intended data structure, which is ussally a fixed-length buffer
* source data is larger than the buffer

## array of pointers
```
int *ptr[3];
```

## void and NULL pointers, and typecasting
```
double x = 100.1;
int *p;
p = (int *) &x;
```
### void pointer
* general pupose pointer
### null pointer
* NULL is defined in <stddef.h>
* initialize a pointer to 0 is equivalent to initializing a pointer to NULL, but NULL is preferred
* the value 0 is the __only__ integer value that can be assigned directly to a pointer variable
# Memory layout of a C program
![Example](/assets/images/post_images/prog24310-w6-1.png)
## Segments
* Text: instructions that the program runs
- usually read-only
* Data: __initialized__ global and static variables
* Bss: __uninitialized__ global and static variables, or these that are initialized to zero
* Stack: stores local variables and return address, it grows **downwards** (high to low address)
- fixed-sized arrays are sotred on the stack
* Heap: memory returned when calling malloc/realloc, it grows **upwards** (low to high address)
* [full details](https://www.geeksforgeeks.org/memory-layout-of-c-program/)

# Dynamic Memory Management in C
* all these memory management functions are from <stdlib.h>
## malloc
```
void *malloc(size_t block_size);
```
* allocates a single block of **block_size** bytes
* returns a pointer to the block (NULL if unable to allocate block)
## calloc
```
void *calloc(size_t num_elements, size_t element_size);
```
* allocates multiple __contiguous__ blocks (unm_elements) of memory, each block of the same element_size bytes
* sets all bytes to zero
* returns a pointer to the block (NULL if unable to allocate block)
## free
```
free(ptr;)
```
* de-allocate the memory
* make sure **malloc** and **free** are paired!
## realloc
```
void *realloc(void* ptr, size_t newsize);
```
* changes the size of the memory block by __deleting__ or __extending__ the memory at the end of the block
