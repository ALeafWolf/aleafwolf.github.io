---
title: PROG24310 Week 4 Note
category: Self-review
tag: PROG24310
---
# Type System
* methods for constructing types, the type equivalence algorithm, type inference rules, and type correctness rules
## Type checking
* detect type errors, at compile time or run time
1. Type inference: process of **attaching** types to expressions
2. Type declaration: **associate** a name with a new data type
3. Type equivalence: rules for determining if two types are the **same**
## Design a Type System
### Rule N1
* all referenced variables much be declared
### Rule N2
* all declared variables much have unique names
### Rule N3
* a program is valid if
- its declarations are valid
- its block body is valid with respect to the type map for these declarations
### Rule N4: Validity of a Statement
#### Assignment
* its target variable is declared
* its source Expression is valid
* ...
#### Conditional
* ...
* ...
#### Loop
* its test Expression is valid and has type bool
* ...
#### Block
* is valid if all its statements are valid
### Rule N5: Validity of a Expression
* a value is always valid
* variable
* binary
* a unary is valid if its expression term is valid
### Rule N6: The type of a Expression
* ...
* ...
* ...
* ...

### Implicit Type Conversion
* question: why no unsigned double float?

# Static and Danamic Typing
* Strong typing
* Static typing: strongly typed and compiler can do all the checking at compile time
## Static and Danamic Typing
* statically typed = types of all variables are __fixed__ when they are **declared at compile time**
* dynamically typed = type of a variable can __vary__ at run time **depending on the value assigned**
## Binding
* an association between an entity and a property
* it is **static** if the association occurs **before** run-time
* it is **dynamic** if the association occurs **at** run-time
## Static Typing
* ...
## Dynamic Typing
* ...

# C: Pre-processor, compiler, linker
## Pre-processor
### #define
* define constants and macros
### #include
* is used to include header files (.h) which contain function prototypes, constant definitions, macro definitions and structure definitions
![Example](/assets/images/post_images/prog24310-w4-1.png)

# Array in C
* in c the array size must fixed, and cannot assign the size with variable
* int*, pass an memory address

# Pointer in C
* &x: address of X
* p = &x: store the address of x
* y = *p: contents of the memory address in p
* **data type as pointer (int*, float*): need to know the size the of variable in order to grab all the bytes of the variable** 
![Example](/assets/images/post_images/prog24310-w4-2.png)